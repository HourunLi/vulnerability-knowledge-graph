import torch
import argparse
import time
import os
import math
import numpy as np
from torch.utils.data import dataset, DataLoader
from torch.autograd import Variable
from model import SetConv
from dataGen import *
from evaluate import *

LEARNING_RATE = 2e-5
def L1Loss(predict, target):
    score = torch.mean(torch.norm(predict-target, p=1, dim=1))
    return score

def MSELoss(predict, target):
    print(predict.shape)
    print(target.shape)
    return torch.mean(torch.pow((predict - target), 2), dim = 1)

def MSELoss_(predict, target):
    print(predict.shape)
    print(target.shape)
    return torch.mean(torch.pow((predict - target), 2))

def train(epochs, batch_size, hid_units, status, model_path, cuda):
    ent_embeddings, des_embeddings, rel_embeddings= load_embed("entity_embeddings.txt", "desp_embeddings.txt", "relation_embeddings.txt")
    train_dataset, test_dataset, valid_dataset = make_data(ent_embeddings, des_embeddings, rel_embeddings)
    train_data_loader = DataLoader(train_dataset, batch_size = batch_size, shuffle = True)
    test_data_loader = DataLoader(test_dataset, batch_size = batch_size)
    valid_data_loader = DataLoader(valid_dataset, batch_size = batch_size)

    ent_feats, rel_feats, descp_feats, hid_units = 200, 200, 768, hid_units

    triple_dict = {}
    triple_dict = getTrainTriple(triple_dict, train_data_loader)
    triple_dict = getTrainTriple(triple_dict, test_data_loader)
    triple_dict = getTrainTriple(triple_dict, valid_data_loader)

    if status == 1:  # new model
        print('Create a new model')
        model = SetConv(ent_feats, descp_feats, rel_feats, hid_units)
    else:
        print('Load pre-trained model from', model_path, 'to continue train')
        model = torch.load(model_path)
    print('\nModel Architecture: \n{}'.format(model))

    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    if cuda:
        model.cuda()

    if status == 3:
        print('Load pre-trained model from', model_path, 'to inference')
        epochs = 0
    else:
        old_loss = 10000000
        model.train()

    criterion = torch.nn.MSELoss()

    for epoch in range(epochs):
        st = time.time()
        loss_total = 0.
        loss_total_ = 0.
        for batch_idx, data_batch in enumerate(train_data_loader):
            head, descption, rel, tail, triple_list= data_batch
            # print(np.shape(data_batch))
            # print(np.shape(head))
            # print(np.shape(descption))
            # print(np.shape(tail))
            # print(head[0:5])
            # print(descption[0:5])
            # print(tail[0:5])
            # print(triple_list[0:5])
            # os.exit()
            head, descption, rel, tail = Variable(head), Variable(descption), Variable(rel), Variable(tail)
            if cuda:
                head, descption, rel, tail = head.cuda(), descption.cuda(), rel.cuda(), tail.cuda()

            optimizer.zero_grad()
            outputs = model(head, descption, rel)
            # print(outputs.shape)
            # print(tail.shape)
            # loss = criterion(outputs, tail.float())
            # print(loss)
            # print(loss.shape)
            # loss = MSELoss(outputs, tail.float())
            # print(loss)
            # print(loss.shape)
            loss = L1Loss(outputs, tail.float())
            # print(loss)
            # print(loss.shape)          
            # os.exit()
            loss_total += loss.item()
            # loss_total_ += MSLE.item()
            loss.backward()
            optimizer.step()
        et = time.time()
        new_loss = loss_total / len(train_data_loader)
        if epoch % 20 == 0:
            print("Epoch {}, time: {:0.5f}, loss: {:0.5f}".format(epoch, et-st, new_loss))
        # if new_loss < old_loss and epoch % 20 == 0:
        #     print('Save model')
        #     torch.save(model, 'model.pth')
        old_loss = new_loss
    
    preds_valid, valid_list = predict(model, valid_data_loader, cuda)
    evaluate(preds_valid, valid_list, ent_embeddings, triple_dict)


def main():
    parser = argparse.ArgumentParser(description='test')
    parser.add_argument(
        "--epochs", help="number of epochs (default: 500)", type=int, default=1000)
    parser.add_argument(
        "--batch", help="batch size (default: 300)", type=int, default=200)
    parser.add_argument(
        "--hid", help="number of hidden units (default: 500)", type=int, default=500)
    parser.add_argument(
        "--status", help="1 for training a new model, 2 for continue training a pre-existing model, 3 for inference directly", type=int, default=1)
    parser.add_argument(
        "--modelPath", help="path of the pre-trained model", default='./model.pth')
    parser.add_argument(
        "--cuda", help="use CUDA", action="store_true")

    args = parser.parse_args()

    train(args.epochs, args.batch, args.hid, args.status, args.modelPath, args.cuda)

if __name__ == "__main__":
    main()
