import torch
import argparse
import time
import os
import math
import numpy as np
from torch.utils.data import dataset, DataLoader
from torch.autograd import Variable
from model import SetConv
from dataGen import *

def cal(pred, ent_embeddings):
    score = torch.FloatTensor(ent_embeddings) - pred
    score = torch.norm(score, p=1, dim=1)
    # print(score)
    # print(score.pow(2))
    # os.exit()
    return score

def evaluate(preds, triple_list, ent_embeddings, triple_dict):
    ind = 0
    mrr , mr = .0, .0
    hit1, hit3, hit10 = .0, .0, .0

    mrr_filter, mr_filter = .0, .0
    hit1_filter, hit3_filter, hit10_filter = .0, .0, .0
    dict_key = triple_dict.keys()
    while ind < len(triple_list):
        rank, rank_filter= 0, 0
        h, t = triple_list[ind][0], triple_list[ind][2]
        h, t = h.item(), t.item()
        pred_tail_emb = preds[ind]
        score = cal(pred_tail_emb, ent_embeddings)
        bench = score[t]
        for i in range(len(score)):
            if i == t:
                continue;
            if score[i] < bench:
                rank += 1
                if h in dict_key and i in triple_dict[h]:
                    continue
                rank_filter += 1
        print(rank)
        if rank < 1:
            hit1 += 1
        if rank < 3:
            hit3 += 1
        if rank < 10:
            hit10 += 1

        if rank_filter < 1:
            hit1_filter += 1
        if rank_filter < 3:
            hit3_filter += 1
        if rank_filter < 10:
            hit10_filter += 1
        
        mrr += 1/(rank+1)
        mr += (rank+1)

        mrr_filter += 1/(rank_filter+1)
        mr_filter += (rank_filter+1)

        ind += 1


    hit1 /= len(preds)
    hit3 /= len(preds)
    hit10 /= len(preds)

    hit1_filter /= len(preds)
    hit3_filter /= len(preds)
    hit10_filter /= len(preds)

    mrr /= len(preds)
    mr /= len(preds)

    mrr_filter /= len(preds)
    mr_filter /= len(preds)
    print("hit1: %f    hit3: %f    hit10: %f" %(hit1, hit3, hit10))
    print("mrr: %f    mr: %f" %(mrr, mr))

    print("filter: hit1: %f    hit3: %f    hit10: %f" %(hit1_filter, hit3_filter, hit10_filter))
    print("filter: mrr: %f    mr: %f" %(mrr_filter, mr_filter))
    return

def predict(model, data_loader, cuda):
    preds = []
    triple_list = []
    model.eval()
    for batch_idx, data_batch in enumerate(data_loader):
        head, descption, rel, tail, pred_list = data_batch
        # print(triple_list[0:5])
        # print(head[0:5])
        # print(descption[0:5])
        # print(rel[0:5])
        # print(tail[0:5])
        head, descption, rel = Variable(head), Variable(descption), Variable(rel)
        if cuda:
            head, descption, rel = head.cuda(), descption.cuda(), rel.cuda()
        t = time.time()
        outputs = model(head, descption, rel)
        for i in range(outputs.data.shape[0]):
            preds.append(outputs.data[i])
            triple_list.append(pred_list[i])
    return preds, triple_list 